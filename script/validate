#!/usr/bin/python3
import argparse
import sys
import os
import hce_utility

CURRENT_DIRECTORY = os.getcwd()
SCRIPT_DIRECTORY = os.path.dirname(os.path.realpath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_PATH/..)
SEPARATOR_REQUIRED = False 
SELECTEDCC=None 
SELECTEDCXX=None 
RUNINFOS = []

class runinfo:
    success = None
    cc = None 
    cxx = None
    loglimit = None
    loglevel = None
    runtime = None

    def __init__(self, success, cc, cxx, limit, level, time):
        self.success = success
        self.cc = cc 
        self.cxx = cxx
        self.loglimit = limit
        self.loglevel = level
        self.runtime = time

    def stringify(self):
        return f'<success:{self.success},cc:{self.cc},cxx:{self.cxx},loglimit:{self.loglimit},loglevel:{self.loglevel}>'

    def __repr__(self):
        return self.stringify()

    def __str__(self):
        return self.stringify()

class log:
    def __call__(string):
        if isinstance(string, str):
            sys.stdout.write(string)

            if newline:
                sys.stdout.write('\n')

            sys.stdout.flush()

    class strings:
        def section():
            return '---------------------------------------------------------------------------------'

        def separator():
            return '[----------] '

        def run():
            return '[ RUN      ] '

        def ok():
            return '[       OK ] '

        def stderr():
            return '[  STDERR  ] '

        def failed():
            return '[  FAILED  ] ' 

    class command:
        def separator():
            global SEPARATOR_REQUIRED
            if SEPARATOR_REQUIRED == False:
                SEPARATOR_REQUIRED = True 
            else:
                log('')
                log(strings.separator())

        def prepend(string):
            log(strings.run()+string+'\n')

        def result(code, string, err=''):
            if code == 0:
                log(strings.ok()+string+'\n')
            else:
                if err != '':
                    log(strings.separator())
                    log(strings.stderr())
                    log(err)
                log(strings.failed()+string)
                log('    ErrorCode: '+str(code)+'\n');

def process_exit(success)
    global RUNINFOS
    log(log.strings.section())
    log('test run information:')

    for r in RUNINFOS:
        print(r)

    log('')
    
    if success == True:
        log('Test Validation Success')
        sys.exit(0)
    else:
        log('Test Validation FAILURE')
        sys.exit(1)

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-cc','--c-compiler', type=str, default=None, required=True, help='Specify the path to a C compiler to build and test with')
    parser.add_argument('-cxx','--cxx-compiler', type=str, default=None, required=True, help='Specify the path to a C++ compiler to build and test with')
    parser.add_argument('-m','--minimal', action='store_true', help='Execute unit tests only once with default options')
    parser.add_argument('-ff','--failfast', action='store_true', help='Cause unit testing to exit as soon as an error is detected')
    parser.add_argument('-lmtb','--loglimit-break', type=int, default=10, help='Skip tests past the specified loglimit. IE, if -lmtb=5, test loop will break when the loglimit reaches a count of 5')
    parser.add_argument('-lvlb','--loglevel-break', type=int, default=10, help='Skip tests past the specified loglevel. IE, if -lvlb=5, test loop will break when the loglevel reaches a count of 5')
    parser.add_argument('-nm','--no-memcheck', action='store_true', help='Skip memory validation')
    parser.add_argument('-otc','--override-test-command', type=str, default=None, help='If specified, the given system command will be executed to run the compiled unit tests. The path to the compiled unit test will be passed as its only argument. The command is expected to return 0 on success, and non-0 on failure')
    parser.add_argument('-omc','--override-memcheck-command', type=str, default=None, help='If specified, the given system command will be executed to run the compiled unit tests when memory verification (valgrind) is expected. The path to the compiled unit test will be passed as its only argument. The command is expected to return 0 on success, and non-0 on failure')
    return parser.parse_args()

def inspect_environment(args):
    def which(program):
        import os
        def is_exe(fpath):
            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

        fpath, fname = os.path.split(program)
        if fpath:
            if is_exe(program):
                return program
        else:
            for path in os.environ.get("PATH", "").split(os.pathsep):
                exe_file = os.path.join(path, program)
                if is_exe(exe_file):
                    return exe_file

        return None

    global SELECTEDCC
    SELECTEDCC = which(args.c_compiler)

    if not SELECTEDCC:
        log(f'Critical Error: No c compiler {args.c_compiler} found!')
        sys.exit(1)

    global CUSTOMCXX
    CUSTOMCXX = which(args.cxx_compiler)

    if not CUSTOMCXX:
        log(f'Critical Error: No c++ compiler {args.cxx_compiler} found!')
        sys.exit(1)

def validate_command(string):
    # indirectly write to this for logfile purposes
    stdout=''

    def print_func(line, flush=True, end=''):
        print(line,flush,end)
        stdout += line

    log.command.prepend(string)

    # execute command with the correct environment and print function
    code, err = execute(string.split(), print_func=print_func, env=env)

    if code == 0:
        log.command.result(code, string)
        return True, stdout
    else:
        log.command.result(code, string, err)
        return False, stdout

def validate_commands(commands):
    success = True
    stdout = ''

    for com in commands:
        success, stdout = validate_command(com) 
        stdouts += stdout

        if not success:
            break 

    return success, stdouts

def build_and_test(args, memcheck)
    global SELECTEDCC
    global SELECTEDCXX

    log(log.strings.section())
    log(f'cc:{args.cc}\ncxx:{args.cxx}\nHCELOGLIMIT:{HCELOGLIMIT}\nHCELOGLEVEL:{HCELOGLEVEL}')

    os.environ['CC'] = SELECTEDCC
    os.environ['CXX'] = SELECTEDCXX
    success = False
    hce_ut_path = os.path.abspath(os.path.join('tst','hce_ut'))
    cmake_cmd = f'cmake {PROJECT_ROOT}'
    clean_cmd = f'make clean'
    make_cmd = f'make hce_ut'
    commands = [ cmake_cmd, clean_cmd, make_cmd ]

    if memcheck:
        if args.override_memcheck_command:
            commands.append(f'args.override_memcheck_command {hce_ut_path}')
        else:
            memcheck_cmd = f'valgrind --leak-check=full {hce_ut_path}'
            commands.append(memcheck_cmd)
    else:
        if args.override_test_command:
            commands.append(f'args.override_test_command {hce_ut_path}')
        else:
            test_cmd = f'{hce_ut_path}'
            commands.append(test_cmd)

    start = datetime.now()
    success, stdout = validate_commands(commands)

    if memcheck:
        memcheck_log = os.path.join(PROJECT_ROOT,f'memcheck.log')

        with open(memcheck_log,'w') as f:
            log(f'writing memcheck build and test output to {memcheck_log}')
            f.write(stdout)

    now = datetime.now()
    global RUNINFOS
    RUNINFOS.append(runinfo(success, args.c_compiler, args.cxx_compiler, loglimit, loglevel, now - start))

    if success == False:
        if args.failfast:
            log('Test Validation FAILURE: exitting early due to enabling --failfast')
            sys.exit(1)
        else:
            log('Test Validation FAILURE')

    return success

def execute_tests(args):
    from datetime import datetime
    success = True
    log.command.separator('build and run unit test code')

    def minimal_test():
        log(f'executing unit tests')

        os.environ['HCELOGLIMIT'] = -1
        os.environ['HCELOGLEVEL'] = -1
        built_and_test(args,False)

        if args.minimal:
            process_exit(success)

    def memcheck_test():
        if not args.no_memcheck:
            log(f'executing unit tests with memcheck')
            os.environ['HCELOGLIMIT'] = -1
            os.environ['HCELOGLEVEL'] = -1
            build_and_test(args,True)

    def jitter_test():
        log(f'executing unit tests with processing jitter')

        # Run the tests with various loglimits, loglevels and compiler toolchains.
        #
        # Executing tests under these all these variations is to:
        # A) verify code correctness 
        # B) smoke out timing bugs by adding semi-random performance jitter
        #
        # Because this will execute the tests potentially hundreds of times, its 
        # important that tests are not written to take a long time. 
        loglevel = -1

        while loglevel < 10:
            if args.loglevel_break == loglevel:
                log(f'reached loglevel breakpoint{args.loglevel_break}')
                break;

            if loglevel:
                log(log.strings.section())

            loglimit = -1; 
            
            while loglimit < 10:
                if args.loglimit_break == loglimit:
                    log(f'reached loglimit breakpoint{args.loglimit_break}')
                    break;

                os.environ['HCELOGLIMIT'] = loglimit
                os.environ['HCELOGLEVEL'] = loglevel
                build_and_test(args,False)

                loglimit=loglimit+1

            loglevel=loglevel+1

    minimal_test()
    memcheck_test()
    jitter_test()
    process_exit(success)

def main():
    global PROJECT_ROOT
    args = parse_args()
    inspect_environment(args)
    os.chdir(PROJECT_ROOT)
    execute_tests(args)

if __name__ == "__main__":
    main()
