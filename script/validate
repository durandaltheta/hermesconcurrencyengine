#!/usr/bin/python3
import argparse
import sys
import os
import hce_utility

CURRENT_DIRECTORY = os.getcwd()
SCRIPT_DIRECTORY = os.path.dirname(os.path.realpath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_PATH/..)
SEPARATOR_REQUIRED = False 
GCC=None 
GXX=None 
CLANGCC=None
CLANGXX=None
CUSTOMCC=None 
CUSTOMXX=None 

class log:
    def __call__(string):
        if isinstance(string, str):
            sys.stdout.write(string)

            if newline:
                sys.stdout.write('\n')

            sys.stdout.flush()

    class strings:
        def section():
            return '---------------------------------------------------------------------------------'

        def separator():
            return '[----------] '

        def run():
            return '[ RUN      ] '

        def ok():
            return '[       OK ] '

        def stderr():
            return '[  STDERR  ] '

        def failed():
            return '[  FAILED  ] ' 

    class command:
        def separator():
            global SEPARATOR_REQUIRED
            if SEPARATOR_REQUIRED == False:
                SEPARATOR_REQUIRED = True 
            else:
                log('')
                log(strings.separator())

        def prepend(string):
            log(strings.run()+string+'\n')

        def result(code, string, err=''):
            if code == 0:
                log(strings.ok()+string+'\n')
            else:
                if err != '':
                    log(strings.separator())
                    log(strings.stderr())
                    log(err)
                log(strings.failed()+string)
                log('    ErrorCode: '+str(code)+'\n');

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-ff','--failfast', action='store_true', help='Cause unit testing to exit as soon as an error is detected')
    parser.add_argument('-ng','--no-gcc', action='store_false', help='Skip validation of gcc toolchain')
    parser.add_argument('-nc','--no-clang', action='store_false', help='Skip validation of clang toolchain')
    parser.add_argument('-ccc','--custom-c-compiler', type=str, default=None, help='Specify a specific C compiler to build and test with. Requires --custom-cxx-compiler also be set')
    parser.add_argument('-ccxx','--custom-cxx-compiler', type=str, default=None, help='Specify a specific C++ compiler to build and test with. Requires --custom-c-compiler also be set')
    parser.add_argument('-lmtb','--loglimit-break', type=int, default=10, help='Skip tests past the specified loglimit. IE, if -lmtb=5, test loop will break when the loglimit reaches a count of 5')
    parser.add_argument('-lvlb','--loglevel-break', type=int, default=10, help='Skip tests past the specified loglevel. IE, if -lvlb=5, test loop will break when the loglevel reaches a count of 5')
    parser.add_argument('-nm','--no-memcheck', action='store_true', help='Skip memory validation')
    parser.add_argument('-otc','--override-test-command', type=str, default=None, help='If specified, the given system command will be executed to run the compiled unit tests. The path to the compiled unit test will be passed as its only argument. The command is expected to return 0 on success, and non-0 on failure')
    parser.add_argument('-omc','--override-memcheck-command', type=str, default=None, help='If specified, the given system command will be executed to run the compiled unit tests when memory verification (valgrind) is expected. The path to the compiled unit test will be passed as its only argument. The command is expected to return 0 on success, and non-0 on failure')
    return parser.parse_args()

def inspect_environment(args):
    def which(program):
        import os
        def is_exe(fpath):
            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

        fpath, fname = os.path.split(program)
        if fpath:
            if is_exe(program):
                return program
        else:
            for path in os.environ.get("PATH", "").split(os.pathsep):
                exe_file = os.path.join(path, program)
                if is_exe(exe_file):
                    return exe_file

        return None

    if not args.no_gcc:
        global GCC
        GCC = which('gcc')

        if not GCC:
            log('Critical Error: No gcc compiler found!')
            sys.exit(1)

        global GXX
        GXX = which('g++')

        if not GXX:
            log('Critical Error: No g++ compiler found!')
            sys.exit(1)

    if not args.no_clang:
        global CLANGCC
        CLANGCC = which('clang')

        if not CLANGCC:
            log('Critical Error: No clang compiler found!')
            sys.exit(1)

        global CLANGXX
        CLANGXX = which('clang++')

        if not CLANGXX:
            log('Critical Error: No clang++ compiler found!')
            sys.exit(1)

    if args.custom_c_compiler and not args.custom_cxx_compiler:
        log('Critical Error: custom c compiler specified but no custom c++ compiler specified')
    elif not args.custom_c_compiler and args.custom_cxx_compiler:
        log('Critical Error: custom c++ compiler specified but no custom c compiler specified')

    elif args.custom_c_compiler and args.custom_cxx_compiler:
        global CUSTOMCC
        CUSTOMCC = which(args.custom_c_compiler)

        if not CUSTOMCC:
            log(f'Critical Error: No {args.custom_c_compiler} compiler found!')
            sys.exit(1)

        global CUSTOMCXX
        CUSTOMCXX = which(args.custom_cxx_compiler)

        if not CUSTOMCXX:
            log(f'Critical Error: No {args.custom_cxx_compiler} compiler found!')
            sys.exit(1)

def validate(string):
    # indirectly write to this for logfile purposes
    stdout=''

    def print_func(line, flush=True, end=''):
        print(line,flush,end)
        stdout += line

    log.command.prepend(string)

    # execute command with the correct environment and print function
    code, err = execute(string.split(), print_func=print_func, env=env)

    if code == 0:
        log.command.result(code, string)
        return True, stdout
    else:
        log.command.result(code, string, err)
        return False, stdout

def validateCommands(commands):
    success = True
    stdout = ''

    for com in commands:
        success, stdout = validate(com) 
        stdouts += stdout

        if not success:
            break 

    return success, stdouts

def buildAndExecuteTests(args):
    class runinfo:
        success = None
        toolchain = None 
        loglimit = None
        loglevel = None
        runtime = None

        def __init__(self, success, chain, limit, level, time):
            self.success = success
            self.toolchain = chain
            self.loglimit = limit
            self.loglevel = level
            self.runtime = time

        def stringify(self):
            return f'<success:{self.success},toolchain:{self.toolchain},loglimit:{self.loglimit},loglevel:{self.loglevel}>'

        def __repr__(self):
            return self.stringify()

        def __str__(self):
            return self.stringify()

    from datetime import datetime

    success = True
    toolchain = None
    loglevel = -1
    loglimit = 0
    runinfos = []
            
    os.environ['HCE_TIMED_TEST_LOGLEVEL_LIMIT'] = args.timed_test_loglevel_limit
    os.chdir(PROJECT_ROOT)
   
    log.command.separator('build and run unit test code')

    def print_runinfos():
        log(log.strings.section())
        log('test run information:')

        for r in runinfos:
            print(r)

        log('')

    def verify_success(success):
        if success == False:
            if args.failfast:
                print_runinfos()
                log('Test Validation FAILURE: exitting early due to failfast argument')
                sys.exit(1)
            else:
                log('Test Validation FAILURE')

    def build_and_test(args, memcheck=False)
        log(log.strings.section())
        log(f'toolchain:{toolchain}\nHCELOGLIMIT:{HCELOGLIMIT}\nHCELOGLEVEL:{HCELOGLEVEL}')

        hce_ut_path = os.path.abspath(os.path.join('tst','hce_ut'))

        cmake_cmd = f'cmake {PROJECT_ROOT}'
        clean_cmd = f'make clean'
        make_cmd = f'make hce_ut'
        commands = [ cmake_cmd, clean_cmd, make_cmd ]

        if memcheck:
            if args.override_memcheck_command:
                commands.append(f'args.override_memcheck_command {hce_ut_path}')
            else:
                memcheck_cmd = f'valgrind --leak-check=full {hce_ut_path}'
                commands.append(memcheck_cmd)
        else:
            if args.override_test_command:
                commands.append(f'args.override_test_command {hce_ut_path}')
            else:
                test_cmd = f'{hce_ut_path}'
                commands.append(test_cmd)

        start = datetime.now()
        success, stdout = validateCommands(commands)

        if memcheck:
            memcheck_log = os.path.join(PROJECT_ROOT,f'memcheck-{toolchain}.log')

            with open(memcheck_log,'w') as f:
                log(f'writing memcheck build and test output to {memcheck_log}')
                f.write(stdout)

        now = datetime.now()
        runinfos.append(runinfo(toolchain, loglimit, loglevel, now - start))
        verify_success(success)

    def test_gcc_compiler(args):
        if not args.no_gcc:
            toolchain = 'gcc'
            global GCC
            global GXX
            os.environ['CC'] = GCC
            os.environ['CXX'] = GXX
            build_and_test(args)

    def test_clang_compiler(args):
        if not args.no_clang:
            toolchain = 'clang'
            global CLANGCC
            global CLANGXX
            os.environ['CC'] = CLANGCC
            os.environ['CXX'] = CLANGXX
            build_and_test(args)

    def test_custom_compiler(args):
        if args.custom_c_compiler and args.custom_cxx_compiler:
            toolchain = 'custom'
            global CUSTOMCC
            global CUSTOMXX
            os.environ['CC'] = CUSTOMCC
            os.environ['CXX'] = CUSTOMXX
            build_and_test(args)

    ############################################################################
    log(f'executing unit tests without logging')

    # ensure logging is disabled
    if 'HCEENABLELOG' in os.environ:
        del os.environ['HCEENABLELOG']

    os.environ['HCELOGLIMIT'] = 0 
    os.environ['HCELOGLEVEL'] = 0 
    test_gcc_compiler(args,memcheck=False)
    test_clang_compiler(args,memcheck=False)
    test_custom_compiler(args,memcheck=False)

    if not args.no_memcheck:
        log(f'executing memcheck on unit tests')
        os.environ['HCELOGLIMIT'] = 0
        os.environ['HCELOGLEVEL'] = 0
        test_gcc_compiler(args,memcheck=True)
        test_clang_compiler(args,memcheck=True)
        test_custom_compiler(args,memcheck=False)

    ############################################################################
    log(f'executing unit tests at designated loglevels and loglimits')
    
    # ensure logging is enabled
    os.environ['HCEENABLELOG'] = 1

    # Run the tests with various loglimits, loglevels and compiler toolchains.
    #
    # Executing tests under these all these variations is to:
    # A) verify code correctness 
    # B) smoke out timing bugs by adding semi-random performance jitter
    #
    # Because this will execute the tests potentially hundreds of times, its 
    # important that tests are not written to take a long time. 
    while loglevel < 10:
        if args.loglevel_break == loglevel:
            log(f'reached loglevel breakpoint{args.loglevel_break}')
            break;

        if loglevel:
            log(log.strings.section())

        loglimit = 0; # reset loglevel before we enter the loop 
        
        while loglimit < 10:
            if args.loglimit_break == loglimit:
                log(f'reached loglimit breakpoint{args.loglimit_break}')
                break;

            os.environ['HCELOGLIMIT'] = loglimit
            os.environ['HCELOGLEVEL'] = loglevel
            test_gcc_compiler(args,memcheck=False)
            test_clang_compiler(args,memcheck=False)
            test_custom_compiler(args,memcheck=False)

            loglimit=loglimit+1

        loglevel=loglevel+1


    ############################################################################ 
    # we're done
    os.chdir(CALLING_PATH)
    print_runinfos()

    if success == True:
        log('Test Validation Success')
        sys.exit(0)
    else:
        log('Test Validation FAILURE')
        sys.exit(1)

def main():
    args = parse_args()
    inspect_environment()
    buildAndExecuteTests(args)

if __name__ == "__main__":
    main()
